open Lwt.Infix
open Cohttp
open Cohttp_lwt_unix
open Yojson.Basic
open Reverse_course_registration
open Csv

(** [generate_spinner_animation width] is a list of animation frames for a
    loading spinner of whitespace of [width]. Each frame contains a camel moving
    across the width of the spinner, creating an animated effect.

    Example:
    - [generate_spinner_animation 10] produces a list of strings with the camel
      moving from left to right through 10 space characters. *)
let generate_spinner_animation width =
  let rec build_frames i acc =
    if i < 0 then List.rev acc
    else
      let left_padding = String.make i ' ' in
      let right_padding = String.make (width - i) ' ' in
      let frame = "ðŸ’»" ^ left_padding ^ "ðŸªðŸŽ“" ^ right_padding ^ "â˜ï¸" in
      build_frames (i - 1) (frame :: acc)
  in
  build_frames width []

(** [loading_spinner animation i start_time] is a promise that continuously
    prints the spinner animation and the elapsed time since [start_time]. The
    spinner frame updates every 0.3 seconds, while the timer updates every 0.01
    seconds.

    - [animation] is the list of animation frames generated by
      [generate_spinner_animation].
    - [i] determines the current iteration of the animation loop.
    - [start_time] is the Unix timestamp when the animation began.

    The promise runs indefinitely, displaying the camel moving across the
    spinner in a loop, until it is explicitly canceled.

    Requires: [start_time] is a valid Unix timestamp. *)
let rec loading_spinner animation i start_time =
  let elapsed_time = Unix.gettimeofday () -. start_time in
  let spinner_frame =
    if i mod 30 = 0 then List.nth animation (i / 30 mod List.length animation)
    else List.nth animation ((i - 1) / 30 mod List.length animation)
  in
  let timer_display =
    Printf.sprintf "     (%.2f seconds elapsed)" elapsed_time
  in
  Lwt_io.printf "\r%s%s" spinner_frame timer_display >>= fun () ->
  Lwt_unix.sleep 0.01 >>= fun () -> loading_spinner animation (i + 1) start_time

let loading_spinner_animation = generate_spinner_animation 40

(** [fetch_courses term] is a promise that resolves with the list of courses
    fetched from the server for the given term. During fetching, a spinner
    animation with a timer is displayed in the console.

    Requires: The server is reachable. *)
let fetch_courses term =
  let start_time = Unix.gettimeofday () in
  Lwt_io.printf
    "OCaml is fetching courses from the cloud... Expect this to take around 90s\n"
  >>= fun () ->
  let spinner_promise =
    loading_spinner loading_spinner_animation 0 start_time
  in
  let courses_promise =
    Lwt_preemptive.detach
      (fun () -> Roster.get_courses (Roster.fetch_all_rosters term))
      ()
  in
  courses_promise >>= fun result ->
  Lwt.cancel spinner_promise;
  Lwt_io.printf "\n\nðŸŽ‰ Done fetching! ðŸŽ‰\n" >>= fun () -> Lwt.return result

(** [parse_intervals_token s] is the list of intervals represented by string
    [s]. Each interval in [s] is a pair of integers separated by a comma, and
    intervals are separated by semicolons.

    Raises: [Invalid_argument] if [s] contains a malformed interval or cannot be
    parsed. Example:
    - [parse_intervals_token "0,10;11,20"] is
      [Course.create_interval (0,10); Course.create_interval (11,20)].
    - [parse_intervals_token ""] raises [Invalid_argument]. *)
let parse_intervals_token (s : string) : Course.interval list =
  (* Split the input string by semicolon to get each interval *)
  if s = "default" then []
  else
    let interval_strings = String.split_on_char ';' s in
    List.map
      (fun interval_str ->
        match String.split_on_char ',' interval_str with
        | [ st; en ] ->
            Course.create_interval (int_of_string st, int_of_string en)
        | _ -> invalid_arg "Invalid interval format")
      interval_strings

(* Retrieve chosen courses based on user input *)
let retrieve_chosen_courses all_courses choices =
  List.fold_left
    (fun (acc, warnings) choice ->
      match
        List.find_opt
          (fun course -> Course.get_title course = choice)
          all_courses
      with
      | Some course -> (course :: acc, warnings)
      | None ->
          let warning =
            "Warning: Course " ^ choice ^ " not found in available courses."
          in
          (acc, warning :: warnings))
    ([], []) choices

(* Generate JSON output for all possible schedules *)
let schedules_json token chosen_courses =
  let schedules =
    Schedule.priority_schedules
      (Schedule.priority_func (parse_intervals_token token))
      chosen_courses
  in
  if schedules = [] then
    `Assoc
      [
        ("error", `String "There are no possible schedules with those courses.");
      ]
  else `List (List.map Schedule.json schedules)

let cors_headers =
  Header.of_list
    [
      ("Access-Control-Allow-Origin", "*");
      ("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
      ("Access-Control-Allow-Headers", "Content-Type");
    ]

let callback all_courses _conn req body =
  let uri = req |> Request.uri |> Uri.path in
  match (uri, Request.meth req) with
  | "/", `OPTIONS ->
      Lwt_io.printf "OPTIONS request received\n" >>= fun () ->
      Server.respond_string ~headers:cors_headers ~status:`No_content ~body:""
        ()
  | "/", `POST -> (
      body |> Cohttp_lwt.Body.to_string >>= fun body_str ->
      Lwt_io.printf "POST request received with body: %s\n" body_str
      >>= fun () ->
      try
        let parts = String.split_on_char ' ' body_str in
        match parts with
        | [] ->
            (* Handle the case where the body is empty *)
            let response_body =
              `Assoc [ ("error", `String "Request body is empty.") ]
              |> Yojson.Basic.pretty_to_string
            in
            Server.respond_string ~headers:cors_headers ~status:`Bad_request
              ~body:response_body ()
        | [ token ] ->
            (* Handle the case where only the token is provided without
               courses *)
            let response_body =
              `Assoc
                [
                  ("error", `String "No course names provided.");
                  ("token", `String token);
                ]
              |> Yojson.Basic.pretty_to_string
            in
            Server.respond_string ~headers:cors_headers ~status:`Bad_request
              ~body:response_body ()
        | token :: course_names ->
            (* Handle the typical case*)
            let chosen_courses, warnings =
              retrieve_chosen_courses all_courses course_names
            in
            let response_body =
              if warnings <> [] then
                `Assoc
                  [
                    ("error", `String "Some courses were not found.");
                    ("warnings", `List (List.map (fun w -> `String w) warnings));
                  ]
                |> Yojson.Basic.pretty_to_string
              else
                (* If no warnings and everything is perfect, send back schedules
                   as a json *)
                schedules_json token chosen_courses
                |> Yojson.Basic.pretty_to_string
            in
            Server.respond_string ~headers:cors_headers ~status:`OK
              ~body:response_body ()
      with exn ->
        Lwt_io.printf "Error during POST request: %s\n" (Printexc.to_string exn)
        >>= fun () ->
        Server.respond_string ~headers:cors_headers
          ~status:`Internal_server_error ~body:"Internal Server Error" ())
  | _ ->
      (* Handle other routes *)
      Lwt_io.printf "Unhandled request to URI: %s\n" uri >>= fun () ->
      Server.respond_string ~headers:cors_headers ~status:`Not_found
        ~body:"Not Found" ()

let server ip port all_courses =
  let callback = callback all_courses in
  Conduit_lwt_unix.init ~src:ip () >>= fun ctx ->
  let ctx = Cohttp_lwt_unix.Client.custom_ctx ~ctx () in
  Lwt_io.printf "Server now running on %s:%d\n" ip port >>= fun () ->
  Server.create ~ctx ~mode:(`TCP (`Port port)) (Server.make ~callback ())

let () =
  try
    if Array.length Sys.argv <> 4 then (
      prerr_endline "Usage: dune exec bin/main.exe <term> <ip> <port>";
      exit 0);
    let term = Sys.argv.(1) in
    let ip = Sys.argv.(2) in
    let port = int_of_string Sys.argv.(3) in
    let all_courses = Lwt_main.run (fetch_courses term) in
    Lwt_main.run (server ip port all_courses)
  with
  | Unix.Unix_error (Unix.EADDRINUSE, _, _) ->
      prerr_endline
        "\n\
         Error: The specified port is already in use. Please use a different \
         port.";
      exit 1
  | Reverse_course_registration.Roster.Invalid_parameters msg ->
      prerr_endline
        ("\n\nError: " ^ msg
       ^ "\n\
          Hint: Make sure to run the server with the correct arguments. \n\
          Usage: dune exec bin/main.exe <term> <ip> <port>\n\
          Example: dune exec bin/main.exe SP25 localhost 9000");
      exit 1
  | exn (* Misc exn *) ->
      prerr_endline
        ("\n\nUnexpected error: " ^ Printexc.to_string exn
       ^ "\n\
          Hint: Make sure to run the server with the correct arguments. \n\
          Usage: dune exec bin/main.exe <term> <ip> <port>\n\
          Example: dune exec bin/main.exe SP25 localhost 9000");
      exit 1
